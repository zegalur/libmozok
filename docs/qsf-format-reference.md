# QSF (Quest Script File) format reference (v.1.0.0)

To assist with world-building tasks, LibMozok introduces a specially designed `.qsf` format for describing the entire process of world creation, initialization, and debug configuration. Script files can be used by the `Server` to load and initialize complex game worlds that include multiple .quest projects and/or other .qsf scripts. The debug information contained in these scripts is used by the `mozok` quest debugging tool to simulate and troubleshoot complex non-linear storylines (for more details, see [debugger.md](debugger.md)).

## Example .qsf scripts

The following examples are based on the tutorial quest from `libmozok-godot`. For a working example, please look at the "tutorial" test for the `mozok_app`.

tutorial.qsf:

```ini
# This file demonstrates how to use .qsf script to describe
# a complex quest world.

version 1 0
script tutorial_test

# Defines a list of worlds.
worlds:
    tut # Tutorial world.

# Defines a list of projects that need to be loaded.
# Format: 
#   [<world_name>] <project_file.quest>
projects:
    [tut] tutorial_utils.quest
    [tut] tutorial_controls.quest
    [tut] tutorial_fighting.quest
    [tut] tutorial_key.quest
    [tut] tutorial_puzzle.quest
    [tut] tutorial_main.quest

# The list of actions to properly initialize the game.
# Format:
#   [<world_name>] <InitActionName>(<arguments>)
init:
    [tut] InitTutorials()

# Defines a list of script files that will loaded by the debugger.
# This list and everything after the `init:` block will be ignored by
# the `Server`.
debug:
    tutorial_debug.qsf
```

tutorial_debugger.qsf:

```ini
# This file demonstrates the usage of special QSF debug commands.
# When PuzzleTutorial_GetHeart is activated we split the timeline by blocking 
# the exit, forcing this quest become unreachable in the alternative timeline.

version 1 0
script tutorial_debugger

worlds: # none
projects: # none
init: # none

# Next commands describe event handlers.
#
# Format:
# <event> <pattern>:
# <BLOCK> <BLOCK_NAME>:
#   <debug_cmd_1> <arguments_1>
#   <debug_cmd_2> <arguments_2>
#   ...
#

# Triggered after all projects are loaded and init actions are applied,
# but before the worker thread starts.
onInit:
ACT ON_INIT:
    print ------------- Hello, world! ------------- 

# Prints a message when `FinishAllTutorials` is activated.
onNewMainQuest [tut] FinishAllTutorials:
ACT TUTORIAL_STARTED:
    print Tutorial quest started, enjoy!

# Cancels the GetHeart subquest when it becomes unreachable.
# This specific quest was designed that way. Normally, we don't need
# to call additional commands to cancel subquests or force goal switches.
# But it's a good demonstration of the ACT_IF block.
onNewQuestStatus [tut] PuzzleTutorial_GetHeart UNREACHABLE:
ACT_IF BLOCK_EXIT:
    push [tut] PTut_Cancel(pt_cell_00, puzzleTutorial, puzzleTutorial_GetHeart)

# Splits the timeline and blocks the exit when `_GetHeart` is activated.
onNewSubQuest [tut] PuzzleTutorial_GetHeart _ _:
SPLIT BLOCK_EXIT:
    # In this branch we expect this quest to fail.
    expect UNREACHABLE [tut] PuzzleTutorial_GetHeart
    # As a consequence, we expect a goal change in the parent quest.
    #expect GOAL_CHANGE [tut] PuzzleTutorial _ 1
    # Block the exit with the stone that can't be moved.
    push [tut] PTut_BlockExit()
    #print First split.
# Uncomment this section to add a second possible split for this event.
# Only one split will activate per timeline.
#SPLIT ANOTHER_ALTERNATIVE_TIMELINE:
#    print Second split.

# Exits the simulation when the search limit is reached.
onSearchLimitReached [tut] _:
ALWAYS SEARCH_LIMIT: 
    exit ERROR: Search limit reached!

# Exits the simulation when the space limit is reached.
onSpaceLimitReached [tut] _:
ALWAYS SPACE_LIMIT: 
    exit ERROR: Space limit reached!

# Triggered when action preconditions hold during the simulation.
# WARNING: Not yet implemented!
#onCheck [tut] KeyTutorial(fightingTutorial, keyTutorial):
#ACT ON_TST_ACTION:
#    print KeyTutorial preconditions holds.

# Triggered when this specific action is pushed 
# by the quest solver during simulation.
onAction [tut] ApplyTutorialAction(pickUpKeyAction):
ACT ON_TST_ACTION:
    print The key was picked up!
```

Visual representation, generated by LibMozok (v1.0.0) and Graphviz (v12.2.1):

<center>
      <picture>
            <img height="750px" alt="Simulation Graph" src="./imgs/simulation_example.svg">
      </picture>
</center>

## Language

The QSF format is derived from the .quest format. Before moving forward, make sure that you are already familiar with the `.quest` language. QSF is a supplementary script format that builds upon and relies on the `.quest` language.

### Header Section

Header is always present and must appear in the following order:

| Keyword | Parameters | Description |
| ------- | ------ | ----------- |
| `version` | `<int> <int>` | Specifies the version of the .qsf file format.
| `script` | `<script_name>` | Sets the script name.
| `worlds:` | - | Defines a list of worlds.
| `projects:` | - | Defines a list of projects that need to be loaded.
| `init:` | - | Defines the list of actions to properly initialize the game.
| `debug:` | - | Defines a list of script files that will loaded by the debugger (**optional**).

### Debug Section Overview

The debug section optional and will be ignored by the `Server` if you load the `.qsf` script using the `Server::loadQuestScriptFile(...)` method.

The debug section consists of **event handlers**, each of which is triggered when a corresponding event with matching arguments occurs. If the arguments match the specified pattern, the associated **debug block** is executed. A debug block - or in a case of `SPLIT`, a set of event blocks - is a sequence of **debug commands** that the debugger executes in order.

Some blocks execute only once per timeline (`ACT` and `SPLIT`), some execute conditionally (`ACT_IF`), and some always execute (`ALWAYS`).

Overall format:

```ini
<Event Handler>:
<Debug Block>:
    <Debug Command>
    <Debug Command>
    ...

<Event Handler>:
<Debug Block>:
    <Debug Command>
    ...
```

### Event Handlers

Some parameters can be written as `_` to indicate a wildcard match (i.e., "any") during pattern matching.

1. `onInit:`<br>
Triggered after all projects have been loaded and initialization actions applied, but before the worker thread starts.

2. `onNewMainQuest [world] MainQuestName:`<br>
Called when a new main quest was found following an applied action.
 
3. `onNewSubQuest [world] SubQuest ParentQuest <parent_goal_int>:`<br>
Triggered when a new subquest is discovered during quest planning. `ParentQuest` and `<goal_int>` may be set to `_` to match any value.
 
4. `onNewQuestStatus [world] QuestName <NEW_STATUS>:`<br>
Triggered when a quest received a new status. `<NEW_STATUS>` may be one of the following:
    - `UNREACHABLE` - The quest can't be completed.
    - `DONE` - Quest has been completed.
 
5. `onSearchLimitReached [world] QuestName:`<br>
Triggered when the search limit is exceeded during quest planning. `QuestName` may be `_`.

6. `onSpaceLimitReached [world] QuestName:`<br>
Triggered when the space limit is exceeded during quest planning. `QuestName` may be `_`.

7. `onAction [world] ActionName(obj1,obj2,...):`<br>
Triggered when an action is about to be added to the action queue during simulation.

### Debug Blocks

1. `ACT BLOCK_NAME:` - Executes the block once per timeline.
2. `ACT_IF SPLIT_NAME:` - Executes once per timeline, but only if a `SPLIT` block with the same name has already been activated in that timeline.
3. `SPLIT SPLIT_NAME:` - Defines a new alternative timeline. If multiple SPLIT blocks are present, only one will be activated in a timeline - others will be skipped. Each activated block executes its debug commands in a separate timeline.
4. `ALWAYS BLOCK_NAME:` - Always executes the block.

### Debug Commands

1. `expect UNREACHABLE [world] QuestName`<br>
Declares that the specified quest is expected to fail. By default, any activated quest is expected to be `DONE`. If the quest ends with a different status, an error will be thrown and the simulation will stop.

2. `push [world] Action(arg1,arg2,)`<br>
Pushes an action into the worker threadâ€™s action queue.

3. `pause Text message`<br>
Pauses the debugger, prints the text message, and opens the debug terminal.

4. `print Text message`<br>
Prints the specified text message to the debugger output.

5. `exit Text Message`<br>
Immediately terminates the debugger, printing the message `EXIT: Text Message`.